# Domain Analysis & Boundary Definition (Step 2.1)
*Understand the business domain deeply before making technical architecture decisions*

## The Domain-First Principle

**Common Mistake:** Teams often start with technical architecture and force the business domain to fit within technical boundaries.

**Better Approach:** Understand the business domain first, then design technical architecture that naturally aligns with business boundaries.

**Why This Matters:** When technical boundaries match business boundaries, the system becomes more maintainable, teams can work independently, and changes are localized to specific business areas.

---

## Quick Domain Assessment (30 Minutes)

### Core Business Questions
Answer these with business stakeholders in the room:

1. **What are the main "things" this system manages?** (customers, orders, products, etc.)
2. **What are the key business processes?** (order fulfillment, customer onboarding, etc.)
3. **Who makes decisions about each "thing"?** (who owns customer data, who approves orders, etc.)
4. **What information flows between processes?** (order triggers inventory check, etc.)
5. **What must happen immediately vs. what can happen later?** (payment processing vs. email notifications)

### Business Boundary Discovery
```
Primary Business Areas:
[ ] Area 1: [Name] - [Key responsibility] - [Decision maker]
[ ] Area 2: [Name] - [Key responsibility] - [Decision maker]  
[ ] Area 3: [Name] - [Key responsibility] - [Decision maker]

Information Flow:
[ ] Area A → Area B: [What information] - [How often] - [How critical]
[ ] Area B → Area C: [What information] - [How often] - [How critical]

Consistency Requirements:
[ ] Immediate consistency needed: [Between which areas and why]
[ ] Eventual consistency acceptable: [Between which areas and why]
```

---

## Comprehensive Domain Discovery Process

### Step 1: Stakeholder Mapping (Week 1)

**Purpose:** Identify everyone who understands or influences the business domain.

#### Stakeholder Categories
```
Domain Experts:
[ ] Business process owners (know how things work today)
[ ] Subject matter experts (understand business rules)
[ ] Operational staff (know real-world edge cases)
[ ] Customer-facing teams (understand user pain points)

Decision Makers:
[ ] Business owners (make policy decisions)
[ ] Compliance officers (understand regulatory requirements)
[ ] Operations managers (optimize for efficiency)
[ ] Customer success teams (optimize for satisfaction)

System Users:
[ ] End users (interact with the system daily)
[ ] Administrative users (manage system configuration)
[ ] Support teams (handle exceptions and problems)
[ ] Reporting users (need data for decision making)
```

#### Stakeholder Interview Template
```
15-Minute Domain Expert Interview:

1. "What does success look like in your area?"
2. "What are the most common problems you deal with?"
3. "What decisions do you make vs. escalate?"
4. "What information do you need from other teams?"
5. "What information do other teams need from you?"
6. "What must happen immediately vs. can wait?"
7. "Who else should I talk to about this area?"
```

### Step 2: Current State Process Mapping (Week 1)

**Purpose:** Document how business processes actually work today, not how they're supposed to work.

#### Process Discovery Techniques

**Process Walking:**
- Follow actual work through the organization
- Observe handoffs between people/teams
- Note where information gets lost or duplicated
- Identify bottlenecks and pain points

**Day in the Life Sessions:**
- Shadow key workers for full business cycles
- Document exceptions and edge cases
- Understand informal processes and workarounds
- Map decision points and escalations

**Data Flow Analysis:**
- Track how information moves through the organization
- Identify data sources and destinations
- Note data transformations and validations
- Document data quality issues

#### Process Documentation Template
```
Process Name: [Customer Order Fulfillment]

Trigger: [Customer places order]
Owner: [Sales team]
Success Criteria: [Order delivered on time and complete]

Steps:
1. [Order received] → [Sales team validates] → [Order system]
2. [Order system] → [Inventory check] → [Warehouse system]  
3. [Inventory confirmed] → [Payment processing] → [Finance system]
4. [Payment confirmed] → [Shipping initiated] → [Logistics system]
5. [Shipped] → [Customer notification] → [CRM system]

Decision Points:
- Inventory insufficient: [Escalate to sales manager]
- Payment failed: [Hold order, notify customer]
- Shipping delayed: [Update customer, offer alternatives]

Information Needs:
- Input: [Customer info, product details, pricing]
- Output: [Order confirmation, tracking info, invoice]
- Dependencies: [Inventory levels, payment authorization, shipping capacity]

Pain Points:
- Manual data entry between systems
- Inventory updates lag behind sales
- Customer notifications delayed
```

### Step 3: Event Storming Sessions (Week 2)

**Purpose:** Collaborative domain modeling that reveals the real business model through the lens of business events.

#### Event Storming Preparation
```
Participants Needed:
- Domain experts (2-3 people who know the business)
- Developers (2-3 who will build the system)
- Product owner (represents user needs)
- Facilitator (keeps session focused)

Materials:
- Large wall space or digital whiteboard
- Sticky notes (orange for events, blue for commands, yellow for actors)
- Markers for writing
- Timeline space (left to right flow)

Time Required:
- Initial session: 4-6 hours
- Follow-up sessions: 2-3 hours each
- Total: 2-3 sessions over 1-2 weeks
```

#### Event Storming Process
```
Phase 1: Event Storm (Chaotic Exploration)
- Put all business events on timeline (orange stickies)
- Don't worry about perfect order
- Focus on "what happens" not "how it happens"
- Include both happy path and exception events

Phase 2: Event Ordering (Temporal Organization)  
- Arrange events in chronological order
- Identify parallel vs. sequential events
- Note dependencies between events
- Highlight critical path events

Phase 3: Actor and Command Identification
- Add who triggers each event (yellow stickies)
- Add what triggers each event (blue stickies)
- Identify decision points and business rules
- Note external system interactions

Phase 4: Boundary Discovery
- Look for natural clustering of related events
- Identify areas with high internal cohesion
- Find boundaries with minimal coupling
- Validate boundaries with domain experts
```

#### Event Storming Output
```
Discovered Events (examples):
- CustomerRegistered
- OrderPlaced  
- PaymentProcessed
- InventoryChecked
- OrderShipped
- CustomerNotified

Identified Boundaries:
- Customer Management (registration, profiles, preferences)
- Order Processing (placement, validation, tracking)
- Payment Handling (authorization, processing, refunds)
- Inventory Management (tracking, allocation, replenishment)
- Shipping & Logistics (carrier selection, tracking, delivery)

Critical Integration Points:
- Order → Inventory (real-time stock check)
- Order → Payment (immediate authorization)
- Payment → Fulfillment (release for shipping)
- Shipping → Customer (delivery notifications)
```

### Step 4: Bounded Context Definition (Week 2)

**Purpose:** Define clear domain boundaries that align with business responsibilities and team structures.

#### Bounded Context Identification
```
Context Definition Criteria:
- Business capability ownership (single team/department)
- Data ownership and authority (who decides what)
- Language consistency (shared vocabulary within boundary)
- Change rate alignment (things that change together)
- Team communication patterns (natural collaboration boundaries)

Bounded Context Template:
Name: [Customer Management]
Purpose: [Manage customer lifecycle and relationships]
Owns: [Customer profiles, preferences, communication history]
Responsibilities:
- Customer registration and authentication
- Profile management and updates
- Communication preferences
- Customer segmentation and targeting

Team: [Customer Success team + 2-3 developers]
Language: [Customer, Profile, Preferences, Segment, Communication]
Interfaces: [CustomerCreated event, CustomerUpdated event, GetCustomer API]

Internal Model:
- Customer (aggregate root)
- Profile (entity)
- Preferences (value object)  
- CommunicationHistory (entity)

External Dependencies:
- Authentication service (identity verification)
- Marketing platform (campaign management)
- Support system (ticket creation)
```

#### Context Relationship Mapping
```
Relationship Types:

Shared Kernel:
- Two contexts share some code/data model
- High coordination required
- Use sparingly, only for stable shared concepts

Customer-Supplier:
- Downstream context depends on upstream
- Upstream has some obligation to downstream
- Examples: Order context depends on Customer context

Conformist:
- Downstream context conforms to upstream model
- No influence on upstream design
- Examples: Reporting context conforms to all operational contexts

Anti-Corruption Layer:
- Downstream context translates upstream model
- Protects downstream from upstream changes
- Examples: New system integrating with legacy systems

Separate Ways:
- Contexts have no relationship
- Duplicate concepts if necessary
- Examples: Internal tools vs. customer-facing systems
```

### Step 5: Integration Strategy Design (Week 2)

**Purpose:** Plan how bounded contexts will communicate while maintaining independence.

#### Integration Pattern Selection
```
Synchronous Integration (when immediate consistency required):
- REST APIs for request-response patterns
- GraphQL for flexible data querying
- Direct database integration (use sparingly)

Asynchronous Integration (when eventual consistency acceptable):
- Domain events for business state changes
- Message queues for reliable delivery
- Event streaming for real-time updates

Data Sharing Approaches:
- Shared databases (avoid if possible)
- Database per service (preferred)
- Event sourcing for audit trails
- CQRS for read/write separation
```

#### Integration Design Template
```
Integration: [Order Processing → Inventory Management]

Pattern: [Asynchronous Event-Driven]
Trigger: [OrderPlaced event]
Data: [ProductId, Quantity, CustomerId, OrderId]
Response: [InventoryAllocated or InsufficientInventory event]

Consistency Requirements:
- Inventory check must happen within 30 seconds
- Order cannot proceed without inventory confirmation
- Partial allocation acceptable for multi-item orders

Failure Handling:
- Retry inventory check up to 3 times
- Escalate to manual process after 5 minutes
- Customer notification if resolution delayed

Technology Choices:
- Event bus: [RabbitMQ/Apache Kafka/Azure Service Bus]
- Message format: [JSON with schema validation]
- Retry mechanism: [Exponential backoff]
- Dead letter handling: [Manual review queue]
```

---

## Practical Tools and Templates

### Domain Discovery Workshop Agenda
```
Domain Discovery Workshop (4 hours)

Hour 1: Current State Mapping
- Stakeholder introductions and roles
- High-level process walkthrough
- Pain point identification
- Information flow mapping

Hour 2: Event Storming  
- Business event identification
- Event ordering and dependencies
- Actor and command mapping
- Critical path analysis

Hour 3: Boundary Discovery
- Event clustering and grouping
- Natural boundary identification
- Ownership and responsibility mapping
- Language and vocabulary alignment

Hour 4: Integration Planning
- Context relationship mapping
- Integration pattern selection  
- Data flow design
- Consistency requirement definition
```

### Ubiquitous Language Dictionary Template
```
Domain: [Order Management]
Last Updated: [Date]

Term: Customer
Definition: Person or organization that purchases products
Usage: Used consistently across Order, Customer, and Payment contexts
Examples: "Customer places order", "Customer payment failed"

Term: Order
Definition: Request to purchase specific products with quantities
Usage: Central concept in Order Processing context
Examples: "Order placed", "Order fulfilled", "Order cancelled"
Aliases: Purchase Request (legacy system), Sales Order (finance)

Term: Product
Definition: Item available for purchase
Usage: Shared concept between Catalog and Order contexts
Examples: "Product in stock", "Product discontinued"
Variations: SKU (inventory), Item (catalog), LineItem (order)
```

### Context Canvas Template
```
Bounded Context: [Name]

Strategic Classification:
□ Core Domain (key business differentiator)
□ Supporting Domain (necessary but not differentiating)  
□ Generic Domain (commodity functionality)

Business Model:
Purpose: [Why this context exists]
Success Metrics: [How success is measured]
Key Stakeholders: [Who cares about this context]

Model:
Core Concepts: [Main entities and aggregates]
Key Processes: [Important business workflows]
Business Rules: [Critical constraints and policies]

Technical Details:
Team: [Who owns this context]
Technology: [Implementation platform/language]
Data Store: [Database or storage approach]
Integration: [How it connects to other contexts]
```

---

## Red Flags and Course Correction

### Domain Analysis Warning Signs
```
Red Flags:
- Domain experts disagree on basic terminology
- Business processes span multiple departments with no clear ownership
- Data flows in circles with no clear source of truth
- Every decision requires multiple approvals from different areas
- "It depends" is the answer to most business rule questions

Course Correction Actions:
- Focus on areas where business has clear ownership
- Start with simpler, well-understood processes
- Create pilot implementations to test understanding
- Schedule regular validation sessions with domain experts
- Document assumptions and validate them incrementally
```

### Boundary Definition Problems
```
Common Issues:
- Boundaries based on technical convenience rather than business logic
- Contexts too large (trying to do everything)
- Contexts too small (excessive communication overhead)
- Unclear ownership of shared concepts
- Integration complexity exceeds team capabilities

Solutions:
- Realign boundaries with business capabilities
- Split large contexts along natural seams
- Merge small contexts with related responsibilities
- Establish clear ownership through team assignment
- Simplify integration patterns and accept some duplication
```

### Event Storming Challenges
```
Session Problems:
- Too many participants (becomes unmanageable)
- Domain experts not engaged (missing critical knowledge)
- Technical focus instead of business focus
- Perfectionism preventing progress
- Scope creep beyond manageable bounds

Facilitation Tips:
- Limit to 6-8 participants maximum
- Ensure domain experts have authority to make decisions
- Keep focus on business events, not technical implementation
- Time-box discussions and move forward
- Define clear scope boundaries before starting
```

---

## Integration with Architecture Decisions

### Domain-Driven Architecture Selection
```
Domain Insights → Architecture Implications:

Clear Boundaries + Stable Teams → Microservices Architecture
- Each bounded context becomes a service
- Teams can work independently
- Technology choices per context

Unclear Boundaries + Single Team → Modular Monolith
- Contexts become modules within single deployment
- Easier to refactor boundaries as understanding improves
- Shared technology stack and database

Complex Integration + Event-Heavy → Event-Driven Architecture
- Business events drive system coordination
- Loose coupling between contexts
- Eventual consistency acceptable

Legacy Integration + Transformation → Strangler Fig Pattern
- New contexts gradually replace legacy functionality
- Anti-corruption layers protect new design
- Incremental migration reduces risk
```

### Technology Alignment
```
Domain Characteristics → Technology Choices:

High Transaction Volume → Event Streaming (Kafka)
Complex Business Rules → Domain-Rich Languages (C#, Java)
Rapid Prototyping → Lightweight Frameworks (Node.js, Python)
Strict Compliance → Audit Trail Technologies (Event Sourcing)
Global Distribution → Eventually Consistent Databases (NoSQL)

Team Skills → Implementation Platform:
.NET Team → Azure/SQL Server ecosystem
Java Team → Spring/PostgreSQL ecosystem  
JavaScript Team → Node.js/MongoDB ecosystem
Python Team → Django/PostgreSQL ecosystem
```

---

## Output Deliverables

### Required Documentation
```
Domain Model Overview:
□ Bounded context map with relationships
□ Core business entities and their relationships  
□ Key business processes and workflows
□ Integration points and data flows

Ubiquitous Language Dictionary:
□ Shared vocabulary across all contexts
□ Term definitions and usage examples
□ Aliases and legacy terminology mapping
□ Context-specific language variations

Event Inventory:
□ Business events by context
□ Event relationships and dependencies
□ Critical path events for key processes
□ Integration events between contexts

Context Specifications:
□ Purpose and responsibilities per context
□ Team ownership and contact information
□ Technology platform and data storage
□ API contracts and event schemas
```

### Validation Checkpoints
```
Domain Understanding Validation:
□ Domain experts agree on context boundaries
□ Business processes map cleanly to contexts
□ Team ownership aligns with business ownership
□ Integration complexity feels manageable

Architecture Alignment Check:
□ Technical architecture supports domain model
□ Technology choices match team capabilities
□ Integration patterns handle identified data flows
□ Non-functional requirements addressed per context

Team Readiness Assessment:
□ Development teams understand their assigned contexts
□ Domain experts available for ongoing questions
□ Context APIs and events defined enough to start
□ Integration testing strategy planned
```

---

## Next Steps

After completing domain analysis, you're ready for:

**Step 2.2:** [Architecture Decision Framework](./2.2_architecture_decision_framework.md) - Choose technical approaches that support your domain model

**Integration Points:**
- Domain boundaries → Service boundaries
- Business processes → API design  
- Event flows → Integration architecture
- Team structure → Deployment strategy
